"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importStar(require("react"));
const bezier_easing_1 = __importDefault(require("bezier-easing"));
// @ts-ignore
const window_scroll_manager_1 = __importDefault(require("window-scroll-manager"));
// ------------ Constants
// Regex that checks for numbers in string
// formatted as "{number}{unit}" where unit is "px", "vh", "%" or none
const START_END_DURATION_REGEX = /^-?\d+(\.\d+)?(px|vh|%)?$/;
const DEFAULT_UNIT = "px";
const DEFAULT_ANGLE_UNIT = "deg";
const ANGLE_PROPERTIES = ["rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY", "skewZ", "hueRotate"];
const EASINGS = {
    ease: [0.25, 0.1, 0.25, 1.0],
    easeIn: [0.42, 0.0, 1.0, 1.0],
    easeOut: [0.0, 0.0, 0.58, 1.0],
    easeInOut: [0.42, 0.0, 0.58, 1.0],
    easeInSine: [0.47, 0, 0.745, 0.715],
    easeOutSine: [0.39, 0.575, 0.565, 1],
    easeInOutSine: [0.445, 0.05, 0.55, 0.95],
    easeInQuad: [0.55, 0.085, 0.68, 0.53],
    easeOutQuad: [0.25, 0.46, 0.45, 0.94],
    easeInOutQuad: [0.455, 0.03, 0.515, 0.955],
    easeInCubic: [0.55, 0.055, 0.675, 0.19],
    easeOutCubic: [0.215, 0.61, 0.355, 1],
    easeInOutCubic: [0.645, 0.045, 0.355, 1],
    easeInQuart: [0.895, 0.03, 0.685, 0.22],
    easeOutQuart: [0.165, 0.84, 0.44, 1],
    easeInOutQuart: [0.77, 0, 0.175, 1],
    easeInQuint: [0.755, 0.05, 0.855, 0.06],
    easeOutQuint: [0.23, 1, 0.32, 1],
    easeInOutQuint: [0.86, 0, 0.07, 1],
    easeInExpo: [0.95, 0.05, 0.795, 0.035],
    easeOutExpo: [0.19, 1, 0.22, 1],
    easeInOutExpo: [1, 0, 0, 1],
    easeInCirc: [0.6, 0.04, 0.98, 0.335],
    easeOutCirc: [0.075, 0.82, 0.165, 1],
    easeInOutCirc: [0.785, 0.135, 0.15, 0.86],
};
// Color regex
// 0 - 199 | 200 - 249 | 250 - 255
const REGEX_0_255 = "(1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])";
// 0.0 - 1.9999...
const REGEX_0_1 = "([01](\\.\\d+)?)";
// 00 - FF
const REGEX_TWO_HEX_DIGITS = "([a-f\\d]{2})";
const HEX_REGEX = new RegExp(`^#${REGEX_TWO_HEX_DIGITS}${REGEX_TWO_HEX_DIGITS}${REGEX_TWO_HEX_DIGITS}$`, "i");
const RGB_REGEX = new RegExp(`^rgb\\(${REGEX_0_255},${REGEX_0_255},${REGEX_0_255}\\)$`, "i");
const RGBA_REGEX = new RegExp(`^rgba\\(${REGEX_0_255},${REGEX_0_255},${REGEX_0_255},${REGEX_0_1}\\)$`, "i");
const SCROLL_OFFSET = 50;
const RESIZE_DEBOUNCE_TIMEOUT = 150;
// CSS transform map
const TRANSFORM_MAP = {
    rotate: (value, unit = DEFAULT_ANGLE_UNIT) => `rotate(${value}${unit})`,
    rotateX: (value, unit = DEFAULT_ANGLE_UNIT) => `rotateX(${value}${unit})`,
    rotateY: (value, unit = DEFAULT_ANGLE_UNIT) => `rotateY(${value}${unit})`,
    rotateZ: (value, unit = DEFAULT_ANGLE_UNIT) => `rotateZ(${value}${unit})`,
    scale: (value) => `scale(${value})`,
    scaleX: (value) => `scaleX(${value})`,
    scaleY: (value) => `scaleY(${value})`,
    scaleZ: (value) => `scaleZ(${value})`,
    skew: (value, unit = DEFAULT_UNIT) => `skew(${value}${unit})`,
    skewX: (value, unit = DEFAULT_UNIT) => `skewX(${value}${unit})`,
    skewY: (value, unit = DEFAULT_UNIT) => `skewY(${value}${unit})`,
    skewZ: (value, unit = DEFAULT_UNIT) => `skewZ(${value}${unit})`,
    translateX: (value, unit = DEFAULT_UNIT) => `translateX(${value}${unit})`,
    translateY: (value, unit = DEFAULT_UNIT) => `translateY(${value}${unit})`,
    translateZ: (value, unit = DEFAULT_UNIT) => `translateZ(${value}${unit})`,
};
// Order of CSS transforms matters
const ORDER_OF_TRANSFORMS = [
    "translateX",
    "translateY",
    "translateZ",
    "skew",
    "skewX",
    "skewY",
    "skewZ",
    "rotate",
    "rotateX",
    "rotateY",
    "rotateZ",
    "scale",
    "scaleX",
    "scaleY",
    "scaleZ",
];
// CSS properties that use color values
const COLOR_PROPERTIES = [
    "backgroundColor",
    "borderBottomColor",
    "borderColor",
    "borderLeftColor",
    "borderRightColor",
    "borderTopColor",
    "color",
    "fill",
    "stroke",
];
// CSS filter map
// blur()
// brightness()
// contrast()
// grayscale()
// hue-rotate()
// invert()
// opacity() // use opacityFilter
// saturate()
// sepia()
// Not supported
// drop-shadow()
// url()
const FILTER_MAP = {
    blur: (value, unit = DEFAULT_UNIT) => `blur(${value}${unit})`,
    brightness: (value) => `brightness(${value})`,
    contrast: (value) => `contrast(${value})`,
    grayscale: (value) => `grayscale(${value})`,
    hueRotate: (value, unit = DEFAULT_ANGLE_UNIT) => `hue-rotate(${value}${unit})`,
    invert: (value) => `invert(${value})`,
    opacityFilter: (value) => `opacity(${value})`,
    saturate: (value) => `saturate(${value})`,
    sepia: (value) => `sepia(${value})`,
};
const FILTER_PROPERTIES = [
    "blur",
    "brightness",
    "contrast",
    "grayscale",
    "hueRotate",
    "invert",
    "opacityFilter",
    "saturate",
    "sepia",
];
// ------------ Helpers
// Get element's top offset
function getElementTop(el) {
    let top = 0;
    let element = el;
    do {
        top += element.offsetTop || 0;
        element = element.offsetParent;
    } while (element);
    return top;
}
// Returns CSS unit
function getUnit(property, unit) {
    let propertyUnit = unit || DEFAULT_UNIT;
    if (ANGLE_PROPERTIES.indexOf(property) >= 0) {
        propertyUnit = unit || DEFAULT_ANGLE_UNIT;
    }
    return propertyUnit;
}
// Takes string value (in px/vh/%) and returns number
function getValueInPx(value, maxScroll) {
    var _a;
    const floatValue = parseFloat(value);
    const unit = ((_a = value.match(START_END_DURATION_REGEX)) === null || _a === void 0 ? void 0 : _a[2]) || null;
    const vh = window.innerHeight / 100;
    let valueInPx;
    switch (unit) {
        case "vh":
            valueInPx = vh * floatValue;
            break;
        case "%":
            valueInPx = (maxScroll * floatValue) / 100;
            break;
        default:
            valueInPx = floatValue;
    }
    return valueInPx;
}
// Takes start/end/duration props
// and return number (in pixels) based on prop type (number, string, dom element)
function convertPropToPixels(propName, propValue, maxScroll, offset = 0) {
    let propValueInPx = propValue;
    const isElement = propValue instanceof HTMLElement;
    const keyCodes = {
        ZERO: 48,
        NINE: 57,
    };
    if (typeof propValue === "number") {
        propValueInPx = propValue;
    }
    else if (START_END_DURATION_REGEX.test(propValue)) {
        propValueInPx = getValueInPx(propValue, maxScroll);
    }
    else if (isElement ||
        (typeof propValue === "string" &&
            (propValue.charCodeAt(0) < keyCodes.ZERO || propValue.charCodeAt(0) > keyCodes.NINE))) {
        const element = isElement ? propValue : document.querySelector(propValue);
        if (!element) {
            console.warn(`Plx, ERROR: ${propName} selector matches no elements: "${propValue}"`);
            return null;
        }
        if (propName === "start" || propName === "end") {
            // START or END
            // Element enters the viewport
            propValueInPx = getElementTop(element) - window.innerHeight;
        }
        else if (propName === "duration") {
            // DURATION
            // Height of the element
            propValueInPx = element.offsetHeight;
        }
    }
    else {
        console.warn(`Plx, ERROR: "${propValue}" is not a valid ${propName} value, check documentation`);
        return null;
    }
    // Transform offset to px
    let offsetInPx = 0;
    if (typeof offset === "number") {
        offsetInPx = offset;
    }
    else if (START_END_DURATION_REGEX.test(offset)) {
        offsetInPx = getValueInPx(offset, maxScroll);
    }
    // Add offset
    propValueInPx += offsetInPx;
    if (propValueInPx < 0) {
        propValueInPx = 0;
    }
    return propValueInPx;
}
// Converts color in hex format into object { r, g, b, a }
function hexToObject(hex) {
    // Convert #abc to #aabbcc
    const color = hex.length === 4 ? `#${hex[1]}${hex[1]}${hex[2]}${hex[2]}${hex[3]}${hex[3]}` : hex;
    const result = HEX_REGEX.exec(color);
    // Safety check, if color is in the wrong format
    if (!result) {
        console.warn(`Plx, ERROR: hex color is not in the right format: "${hex}"`);
        return null;
    }
    // All color functions are returning { r, g, b, a } object
    return {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16),
        a: 1,
    };
}
// Converts color in rgb format into object { r, g, b, a }
function rgbToObject(rgb) {
    const isRgba = rgb.toLowerCase().indexOf("rgba") === 0;
    const color = rgb.replace(/ /g, "");
    const result = isRgba ? RGBA_REGEX.exec(color) : RGB_REGEX.exec(color);
    // Safety check, if color is in the wrong format
    if (!result) {
        console.warn(`Plx, ERROR: rgb or rgba color is not in the right format: "${rgb}"`);
        return null;
    }
    // All color functions are returning { r, g, b, a } object
    return {
        r: parseInt(result[1], 10),
        g: parseInt(result[2], 10),
        b: parseInt(result[3], 10),
        a: isRgba ? parseFloat(result[4]) : 1,
    };
}
// Calculates the current value for parallax-ing property
function parallax(scrollPosition, start, duration, startValue, endValue, easing) {
    // Safety check, if "startValue" is in the wrong format
    if (typeof startValue !== "number") {
        console.warn(`Plx, ERROR: startValue is not a number (type: "${typeof endValue}", value: "${endValue}")`);
        return 0;
    }
    // Safety check, if "endValue" is in the wrong format
    if (typeof endValue !== "number") {
        console.warn(`Plx, ERROR: endValue is not a number (type: "${typeof endValue}", value: "${endValue}")`);
        return 0;
    }
    // Safety check, if "duration" is in the wrong format
    if (typeof duration !== "number" || duration === 0) {
        console.warn(`Plx, ERROR: duration is zero or not a number (type: "${typeof duration}", value: "${duration}")`);
        return 0;
    }
    let min = startValue;
    let max = endValue;
    const invert = startValue > endValue;
    if (invert) {
        min = endValue;
        max = startValue;
    }
    let percentage = (scrollPosition - start) / duration;
    if (percentage > 1) {
        percentage = 1;
    }
    else if (percentage < 0) {
        percentage = 0;
    }
    // Apply easing
    if (easing) {
        if (Array.isArray(easing)) {
            percentage = (0, bezier_easing_1.default)(easing[0], easing[1], easing[2], easing[3])(percentage);
        }
        else if (typeof easing === "string" && EASINGS[easing]) {
            percentage = (0, bezier_easing_1.default)(EASINGS[easing][0], EASINGS[easing][1], EASINGS[easing][2], EASINGS[easing][3])(percentage);
        }
        else if (typeof easing === "function") {
            percentage = easing(percentage);
        }
    }
    let value = percentage * (max - min);
    if (invert) {
        value = max - value;
    }
    else {
        value += min;
    }
    // Rounding to 4 decimals (.toFixed(4) returns a string)
    return Math.floor(value * 10000) / 10000;
}
// Calculates current value for color parallax
function colorParallax(scrollPosition, start, duration, startValue, endValue, easing) {
    let startObject = null;
    let endObject = null;
    if (typeof startValue === "string") {
        if (startValue[0].toLowerCase() === "r") {
            startObject = rgbToObject(startValue);
        }
        else {
            startObject = hexToObject(startValue);
        }
    }
    if (typeof endValue === "string") {
        if (endValue[0].toLowerCase() === "r") {
            endObject = rgbToObject(endValue);
        }
        else {
            endObject = hexToObject(endValue);
        }
    }
    if (startObject && endObject) {
        const r = parallax(scrollPosition, start, duration, startObject.r, endObject.r, easing);
        const g = parallax(scrollPosition, start, duration, startObject.g, endObject.g, easing);
        const b = parallax(scrollPosition, start, duration, startObject.b, endObject.b, easing);
        const a = parallax(scrollPosition, start, duration, startObject.a, endObject.a, easing);
        return `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}, ${a})`;
    }
    return "";
}
// Applies property parallax to the style object
function applyPropertyToStyle(scrollPosition, propertyData, startPosition, duration, style, transforms, filters, easing) {
    const { startValue, endValue, property, unit } = propertyData;
    // If property is one of the color properties
    // Use it's parallax method
    const isColor = COLOR_PROPERTIES.indexOf(property) > -1;
    const parallaxMethod = isColor ? colorParallax : parallax;
    // Get new CSS value
    const value = parallaxMethod(scrollPosition, startPosition, duration, startValue, endValue, easing);
    // Get transform function
    const transformMethod = TRANSFORM_MAP[property];
    const filterMethod = FILTER_MAP[property];
    const newStyle = style;
    if (transformMethod) {
        // Get CSS unit
        const propertyUnit = getUnit(property, unit);
        // Transforms, apply value to transform function
        transforms[property] = transformMethod(value, propertyUnit);
    }
    else if (filterMethod) {
        // Get CSS unit
        const propertyUnit = getUnit(property, unit);
        // Filters, apply value to filter function
        filters[property] = filterMethod(value, propertyUnit);
    }
    else {
        // All other properties
        newStyle[property] = value;
        // Add unit if it is passed
        if (unit) {
            newStyle[property] += unit;
        }
    }
}
// Returns CSS classes based on animation state
function getClasses(lastSegmentScrolledBy, isInSegment, parallaxData) {
    let cssClasses = "";
    if (lastSegmentScrolledBy === null) {
        cssClasses = "Plx--above";
    }
    else if (lastSegmentScrolledBy === parallaxData.length - 1 && !isInSegment) {
        cssClasses = "Plx--below";
    }
    else if (lastSegmentScrolledBy !== null && isInSegment) {
        const segmentName = parallaxData[lastSegmentScrolledBy].name || lastSegmentScrolledBy;
        cssClasses = `Plx--active Plx--in Plx--in-${segmentName}`;
    }
    else if (lastSegmentScrolledBy !== null && !isInSegment) {
        const segmentName = parallaxData[lastSegmentScrolledBy].name || lastSegmentScrolledBy;
        const nextSegmentName = parallaxData[lastSegmentScrolledBy + 1].name || lastSegmentScrolledBy + 1;
        cssClasses = `Plx--active Plx--between Plx--between-${segmentName}-and-${nextSegmentName}`;
    }
    return cssClasses;
}
// Checks if class contains 'active'
function checkIsActive(classes) {
    return classes.indexOf("Plx--active") > -1;
}
// Main update function
// Returns new state object based on props and scroll position
function updateDOM(scrollPosition, props, showElement, propsUsedInParallax, plxStyleRef, plxStateClassesRef, elementRef) {
    const { animateWhenNotInViewport, disabled, freeze, parallaxData, className, onPlxEnd, onPlxStart, style } = props;
    const plxStyle = plxStyleRef.current;
    const plxStateClasses = plxStateClassesRef.current;
    const element = elementRef.current;
    // Do nothing if animation is disabled, frozen
    // or if element is not rendered yet
    if ((freeze && showElement) || !element || disabled) {
        return;
    }
    // Check if element is in viewport
    // Small offset is added to prevent page jumping
    if (!animateWhenNotInViewport) {
        const rect = element.getBoundingClientRect();
        const isTopAboveBottomEdge = rect.top < window.innerHeight + SCROLL_OFFSET;
        const isBottomBelowTopEdge = rect.top + rect.height > -SCROLL_OFFSET;
        if (!isTopAboveBottomEdge || !isBottomBelowTopEdge) {
            return;
        }
    }
    // Style to be applied to our element
    let newStyle = {};
    const transforms = {};
    const filters = {};
    const appliedProperties = [];
    const segments = [];
    let isInSegment = false;
    let lastSegmentScrolledBy = null;
    const bodyHeight = document.documentElement.scrollHeight || document.body.scrollHeight;
    const maxScroll = bodyHeight - window.innerHeight;
    for (let i = 0; i < parallaxData.length; i++) {
        const { duration, easing, endOffset, properties, startOffset } = parallaxData[i];
        const start = parallaxData[i].start === "self" ? element : parallaxData[i].start;
        const end = parallaxData[i].end === "self" ? element : parallaxData[i].end;
        const startInPx = convertPropToPixels("start", start, maxScroll, startOffset);
        let durationInPx;
        let endInPx;
        // End has higher priority than duration
        if (typeof end !== "undefined") {
            endInPx = convertPropToPixels("end", end, maxScroll, endOffset);
            durationInPx = endInPx - startInPx;
        }
        else {
            durationInPx = convertPropToPixels("duration", duration, maxScroll);
            endInPx = startInPx + durationInPx;
        }
        // If segment is below scroll position skip it
        if (scrollPosition < startInPx) {
            break;
        }
        const isScrolledByStart = scrollPosition >= startInPx;
        if (isScrolledByStart) {
            lastSegmentScrolledBy = i;
        }
        // If active segment exists, apply his properties
        if (scrollPosition >= startInPx && scrollPosition <= endInPx) {
            isInSegment = true;
            properties.forEach((propertyData) => {
                const { property } = propertyData;
                // Save which properties are applied to the active segment
                // So they are not re-applied for other segments
                appliedProperties.push(property);
                // Apply property style
                applyPropertyToStyle(scrollPosition, propertyData, startInPx, durationInPx, newStyle, transforms, filters, easing);
            });
        }
        else {
            // Push non active segments above the scroll position to separate array
            // This way "durationInPx" and "startInPx" are not calculated again
            // and segments below scroll position are skipped in the next step
            segments.push({
                easing,
                durationInPx,
                properties,
                startInPx,
            });
        }
    }
    // These are only segments that are completely above scroll position
    segments.forEach((data) => {
        const { easing, durationInPx, properties, startInPx } = data;
        properties.forEach((propertyData) => {
            const { property } = propertyData;
            // Skip property that was changed for active segment
            if (appliedProperties.indexOf(property) > -1) {
                return;
            }
            // These styles that are the ones changed by segments
            // that are above active segment
            applyPropertyToStyle(scrollPosition, propertyData, startInPx, durationInPx, newStyle, transforms, filters, easing);
        });
    });
    // Sort transforms by ORDER_OF_TRANSFORMS
    // as order of CSS transforms matters
    const transformsOrdered = [];
    ORDER_OF_TRANSFORMS.forEach((transformKey) => {
        if (transforms[transformKey]) {
            transformsOrdered.push(transforms[transformKey]);
        }
    });
    // Concat transforms and add webkit prefix
    newStyle.transform = transformsOrdered.join(" ");
    newStyle.webkitTransform = newStyle.transform;
    const filtersArray = [];
    FILTER_PROPERTIES.forEach((filterKey) => {
        if (filters[filterKey]) {
            filtersArray.push(filters[filterKey]);
        }
    });
    // Concat filters and add webkit prefix
    newStyle.filter = filtersArray.join(" ");
    newStyle.webkitFilter = newStyle.filter;
    // "Stupid" check if style should be updated
    if (JSON.stringify(plxStyle) !== JSON.stringify(newStyle)) {
        // Set styles
        requestAnimationFrame(() => {
            // Add user styles
            for (const property in style) {
                // @ts-ignore
                element.style[property] = style[property];
            }
            // Add parallax styles
            propsUsedInParallax.forEach((property) => {
                // @ts-ignore
                element.style[property] = typeof newStyle[property] === "undefined" ? "" : newStyle[property];
            });
        });
        plxStyleRef.current = newStyle;
    }
    // Adding state classes
    const newPlxStateClasses = getClasses(lastSegmentScrolledBy, isInSegment, parallaxData);
    if (newPlxStateClasses !== plxStateClasses) {
        const newClassName = `${className} Plx ${newPlxStateClasses}`;
        if (newClassName !== element.className) {
            const wasActive = checkIsActive(element.className);
            const isActive = checkIsActive(newClassName);
            element.className = newClassName;
            // Callbacks
            if (!wasActive && isActive) {
                onPlxStart === null || onPlxStart === void 0 ? void 0 : onPlxStart();
            }
            else if (wasActive && !isActive) {
                onPlxEnd === null || onPlxEnd === void 0 ? void 0 : onPlxEnd();
            }
        }
        // Cache plx classes
        plxStateClassesRef.current = newPlxStateClasses;
    }
}
const Plx = (props) => {
    const { animateWhenNotInViewport = false, children, className = "", disabled = false, freeze = false, parallaxData, style = {}, onPlxStart, onPlxEnd, tagName: ElementTag = "div" } = props, elementProps = __rest(props, ["animateWhenNotInViewport", "children", "className", "disabled", "freeze", "parallaxData", "style", "onPlxStart", "onPlxEnd", "tagName"]);
    const scrollManager = (0, react_1.useRef)();
    const resizeTimeout = (0, react_1.useRef)();
    const element = (0, react_1.useRef)(null);
    const plxStyle = (0, react_1.useRef)({});
    const plxStyleClasses = (0, react_1.useRef)("");
    const [showElement, setShowElement] = (0, react_1.useState)(false);
    // Get properties that are used in a parallax effect
    const propsUsedInParallax = (0, react_1.useMemo)(() => {
        const properties = [];
        parallaxData.forEach((segment) => {
            segment.properties.forEach(({ property }) => {
                const transformMethod = TRANSFORM_MAP[property];
                const filterMethod = FILTER_MAP[property];
                if (transformMethod) {
                    if (!properties.includes("transform")) {
                        properties.push("transform", "webkitTransform");
                    }
                }
                else if (filterMethod) {
                    if (!properties.includes("filter")) {
                        properties.push("filter", "webkitFilter");
                    }
                }
                else {
                    if (!properties.includes(property)) {
                        properties.push(property);
                    }
                }
            });
        });
        return properties;
    }, [parallaxData]);
    // Set will-change property
    (0, react_1.useEffect)(() => {
        if (element.current) {
            element.current.style.willChange = propsUsedInParallax
                .map((str) => {
                return str.replace(/[A-Z]/g, (letter) => `-${letter.toLowerCase()}`).replace("webkit", "-webkit");
            })
                .join(",");
        }
    }, [element, propsUsedInParallax]);
    const update = (0, react_1.useCallback)((scrollPosition = null) => {
        const currentScrollPosition = scrollPosition === null ? scrollManager.current.getScrollPosition().scrollPositionY : scrollPosition;
        updateDOM(currentScrollPosition, props, showElement, propsUsedInParallax, plxStyle, plxStyleClasses, element);
    }, [props]);
    // Window resize
    const handleResize = (0, react_1.useCallback)(() => {
        clearTimeout(resizeTimeout.current);
        resizeTimeout.current = setTimeout(() => {
            update();
        }, RESIZE_DEBOUNCE_TIMEOUT);
    }, [props]);
    (0, react_1.useEffect)(() => {
        if (scrollManager.current) {
            if (disabled) {
                // When disabled leave only user styles
                propsUsedInParallax.forEach((property) => {
                    if (element.current) {
                        // @ts-ignore
                        element.current.style[property] = "";
                    }
                });
            }
            else {
                update();
            }
        }
    }, [disabled]);
    // Window scroll
    const handleScrollChange = (0, react_1.useCallback)((e) => {
        update(e.detail.scrollPositionY);
    }, [props]);
    (0, react_1.useEffect)(() => {
        // Get scroll manager singleton
        scrollManager.current = new window_scroll_manager_1.default();
        // Add listeners
        window.addEventListener("window-scroll", handleScrollChange);
        window.addEventListener("resize", handleResize);
        update();
        setShowElement(true);
        return () => {
            clearTimeout(resizeTimeout.current);
            window.removeEventListener("window-scroll", handleScrollChange);
            window.removeEventListener("resize", handleResize);
            scrollManager.current.removeListener();
        };
    }, [props]);
    // Update DOM on props change
    (0, react_1.useEffect)(() => {
        update();
    }, []);
    let elementStyle = style;
    if (!disabled) {
        elementStyle = Object.assign(Object.assign({}, style), { 
            // Hide element before until it is rendered
            // This prevents jumps if page is scrolled and then refreshed
            visibility: showElement ? undefined : "hidden" });
    }
    return (react_1.default.createElement(ElementTag, Object.assign({}, elementProps, { className: `${className} Plx`, style: elementStyle, ref: element }), children));
};
exports.default = Plx;
