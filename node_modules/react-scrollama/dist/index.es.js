import * as React from 'react';
import React__default, { useState, useMemo, useRef, useCallback } from 'react';

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var isOffsetInPixels = function isOffsetInPixels(offset) {
  return typeof offset === 'string' && offset.includes('px');
};

var markerStyles = {
  position: 'fixed',
  left: 0,
  width: '100%',
  height: 0,
  borderTop: '2px dashed black',
  zIndex: 9999
};
var offsetTextStyles = {
  fontSize: '12px',
  fontFamily: 'monospace',
  margin: 0,
  padding: 6
};

var useTop = function useTop(offset) {
  var offsetInPixels = isOffsetInPixels(offset);

  if (offsetInPixels) {
    return offset;
  } else {
    return "".concat(offset * 100, "%");
  }
};

var DebugOffset = function DebugOffset(_ref) {
  var offset = _ref.offset;
  var top = useTop(offset);
  return /*#__PURE__*/React__default.createElement("div", {
    style: _objectSpread2(_objectSpread2({}, markerStyles), {}, {
      top: top
    })
  }, /*#__PURE__*/React__default.createElement("p", {
    style: offsetTextStyles
  }, "trigger: ", offset));
};

var createThreshold = function createThreshold(theta, height) {
  var count = Math.ceil(height / theta);
  var t = [];
  var ratio = 1 / count;

  for (var i = 0; i <= count; i += 1) {
    t.push(i * ratio);
  }

  return t;
};

var Scrollama = function Scrollama(props) {
  var debug = props.debug,
      children = props.children,
      offset = props.offset,
      onStepEnter = props.onStepEnter,
      onStepExit = props.onStepExit,
      onStepProgress = props.onStepProgress,
      threshold = props.threshold;
  var isOffsetDefinedInPixels = isOffsetInPixels(offset);

  var _useState = useState(0),
      _useState2 = _slicedToArray(_useState, 2),
      lastScrollTop = _useState2[0],
      setLastScrollTop = _useState2[1];

  var _useState3 = useState(null),
      _useState4 = _slicedToArray(_useState3, 2),
      windowInnerHeight = _useState4[0],
      setWindowInnerHeight = _useState4[1];

  var handleSetLastScrollTop = function handleSetLastScrollTop(scrollTop) {
    setLastScrollTop(scrollTop);
  };

  var handleWindowResize = function handleWindowResize(e) {
    setWindowInnerHeight(window.innerHeight);
  };

  React__default.useEffect(function () {
    if (isOffsetDefinedInPixels) {
      window.addEventListener('resize', handleWindowResize);
      return function () {
        window.removeEventListener('resize', handleWindowResize);
      };
    }
  }, []);
  var isBrowser = typeof window !== "undefined";
  var innerHeight = isBrowser ? windowInnerHeight || window.innerHeight : 0;
  var offsetValue = isOffsetDefinedInPixels ? +offset.replace('px', '') / innerHeight : offset;
  var progressThreshold = useMemo(function () {
    return createThreshold(threshold, innerHeight);
  }, [innerHeight]);
  return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, debug && /*#__PURE__*/React__default.createElement(DebugOffset, {
    offset: offset
  }), React__default.Children.map(children, function (child, i) {
    return /*#__PURE__*/React__default.cloneElement(child, {
      scrollamaId: "react-scrollama-".concat(i),
      offset: offsetValue,
      onStepEnter: onStepEnter,
      onStepExit: onStepExit,
      onStepProgress: onStepProgress,
      lastScrollTop: lastScrollTop,
      handleSetLastScrollTop: handleSetLastScrollTop,
      progressThreshold: progressThreshold,
      innerHeight: innerHeight
    });
  }));
};

Scrollama.defaultProps = {
  onStepProgress: null,
  onStepEnter: function onStepEnter() {},
  onStepExit: function onStepExit() {},
  threshold: 4,
  offset: 0.3
};

const observerMap = new Map();
const RootIds = new WeakMap();
let rootId = 0;
let unsupportedValue = undefined;
/**
 * Generate a unique ID for the root element
 * @param root
 */

function getRootId(root) {
  if (!root) return '0';
  if (RootIds.has(root)) return RootIds.get(root);
  rootId += 1;
  RootIds.set(root, rootId.toString());
  return RootIds.get(root);
}
/**
 * Convert the options to a string Id, based on the values.
 * Ensures we can reuse the same observer when observing elements with the same options.
 * @param options
 */


function optionsToId(options) {
  return Object.keys(options).sort().filter(key => options[key] !== undefined).map(key => {
    return `${key}_${key === 'root' ? getRootId(options.root) : options[key]}`;
  }).toString();
}

function createObserver(options) {
  // Create a unique ID for this observer instance, based on the root, root margin and threshold.
  let id = optionsToId(options);
  let instance = observerMap.get(id);

  if (!instance) {
    // Create a map of elements this observer is going to observe. Each element has a list of callbacks that should be triggered, once it comes into view.
    const elements = new Map();
    let thresholds;
    const observer = new IntersectionObserver(entries => {
      entries.forEach(entry => {
        var _elements$get;

        // While it would be nice if you could just look at isIntersecting to determine if the component is inside the viewport, browsers can't agree on how to use it.
        // -Firefox ignores `threshold` when considering `isIntersecting`, so it will never be false again if `threshold` is > 0
        const inView = entry.isIntersecting && thresholds.some(threshold => entry.intersectionRatio >= threshold); // @ts-ignore support IntersectionObserver v2

        if (options.trackVisibility && typeof entry.isVisible === 'undefined') {
          // The browser doesn't support Intersection Observer v2, falling back to v1 behavior.
          // @ts-ignore
          entry.isVisible = inView;
        }

        (_elements$get = elements.get(entry.target)) == null ? void 0 : _elements$get.forEach(callback => {
          callback(inView, entry);
        });
      });
    }, options); // Ensure we have a valid thresholds array. If not, use the threshold from the options

    thresholds = observer.thresholds || (Array.isArray(options.threshold) ? options.threshold : [options.threshold || 0]);
    instance = {
      id,
      observer,
      elements
    };
    observerMap.set(id, instance);
  }

  return instance;
}
/**
 * @param element - DOM Element to observe
 * @param callback - Callback function to trigger when intersection status changes
 * @param options - Intersection Observer options
 * @param fallbackInView - Fallback inView value.
 * @return Function - Cleanup function that should be triggered to unregister the observer
 */


function observe(element, callback, options = {}, fallbackInView = unsupportedValue) {
  if (typeof window.IntersectionObserver === 'undefined' && fallbackInView !== undefined) {
    const bounds = element.getBoundingClientRect();
    callback(fallbackInView, {
      isIntersecting: fallbackInView,
      target: element,
      intersectionRatio: typeof options.threshold === 'number' ? options.threshold : 0,
      time: 0,
      boundingClientRect: bounds,
      intersectionRect: bounds,
      rootBounds: bounds
    });
    return () => {// Nothing to cleanup
    };
  } // An observer with the same options can be reused, so lets use this fact


  const {
    id,
    observer,
    elements
  } = createObserver(options); // Register the callback listener for this element

  let callbacks = elements.get(element) || [];

  if (!elements.has(element)) {
    elements.set(element, callbacks);
  }

  callbacks.push(callback);
  observer.observe(element);
  return function unobserve() {
    // Remove the callback from the callback list
    callbacks.splice(callbacks.indexOf(callback), 1);

    if (callbacks.length === 0) {
      // No more callback exists for element, so destroy it
      elements.delete(element);
      observer.unobserve(element);
    }

    if (elements.size === 0) {
      // No more elements are being observer by this instance, so destroy it
      observer.disconnect();
      observerMap.delete(id);
    }
  };
}

/**
 * React Hooks make it easy to monitor the `inView` state of your components. Call
 * the `useInView` hook with the (optional) [options](#options) you need. It will
 * return an array containing a `ref`, the `inView` status and the current
 * [`entry`](https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry).
 * Assign the `ref` to the DOM element you want to monitor, and the hook will
 * report the status.
 *
 * @example
 * ```jsx
 * import React from 'react';
 * import { useInView } from 'react-intersection-observer';
 *
 * const Component = () => {
 *   const { ref, inView, entry } = useInView({
 *       threshold: 0,
 *   });
 *
 *   return (
 *     <div ref={ref}>
 *       <h2>{`Header inside viewport ${inView}.`}</h2>
 *     </div>
 *   );
 * };
 * ```
 */

function useInView({
  threshold,
  delay,
  trackVisibility,
  rootMargin,
  root,
  triggerOnce,
  skip,
  initialInView,
  fallbackInView,
  onChange
} = {}) {
  const unobserve = React.useRef();
  const callback = React.useRef();
  const [state, setState] = React.useState({
    inView: !!initialInView
  }); // Store the onChange callback in a `ref`, so we can access the latest instance inside the `useCallback`.

  callback.current = onChange;
  const setRef = React.useCallback(node => {
    if (unobserve.current !== undefined) {
      unobserve.current();
      unobserve.current = undefined;
    } // Skip creating the observer


    if (skip) return;

    if (node) {
      unobserve.current = observe(node, (inView, entry) => {
        setState({
          inView,
          entry
        });
        if (callback.current) callback.current(inView, entry);

        if (entry.isIntersecting && triggerOnce && unobserve.current) {
          // If it should only trigger once, unobserve the element after it's inView
          unobserve.current();
          unobserve.current = undefined;
        }
      }, {
        root,
        rootMargin,
        threshold,
        // @ts-ignore
        trackVisibility,
        // @ts-ignore
        delay
      }, fallbackInView);
    }
  }, // We break the rule here, because we aren't including the actual `threshold` variable
  // eslint-disable-next-line react-hooks/exhaustive-deps
  [// If the threshold is an array, convert it to a string so it won't change between renders.
  // eslint-disable-next-line react-hooks/exhaustive-deps
  Array.isArray(threshold) ? threshold.toString() : threshold, root, rootMargin, triggerOnce, skip, trackVisibility, fallbackInView, delay]);
  /* eslint-disable-next-line */

  React.useEffect(() => {
    if (!unobserve.current && state.entry && !triggerOnce && !skip) {
      // If we don't have a ref, then reset the state (unless the hook is set to only `triggerOnce` or `skip`)
      // This ensures we correctly reflect the current state - If you aren't observing anything, then nothing is inView
      setState({
        inView: !!initialInView
      });
    }
  });
  const result = [setRef, state.inView, state.entry]; // Support object destructuring, by adding the specific values.

  result.ref = result[0];
  result.inView = result[1];
  result.entry = result[2];
  return result;
}

var useRootMargin = function useRootMargin(offset) {
  return "-".concat(offset * 100, "% 0px -").concat(100 - offset * 100, "% 0px");
};

var useProgressRootMargin = function useProgressRootMargin(direction, offset, node, innerHeight) {
  if (!node.current) return '0px';
  var offsetHeight = node.current.offsetHeight / innerHeight;
  if (direction === 'down') return "".concat((offsetHeight - offset) * 100, "% 0px ").concat(offset * 100 - 100, "% 0px");
  return "-".concat(offset * 100, "% 0px ").concat(offsetHeight * 100 - (100 - offset * 100), "% 0px");
};

var Step = function Step(props) {
  var children = props.children,
      data = props.data,
      handleSetLastScrollTop = props.handleSetLastScrollTop,
      lastScrollTop = props.lastScrollTop,
      onStepEnter = props.onStepEnter,
      onStepExit = props.onStepExit,
      onStepProgress = props.onStepProgress,
      offset = props.offset,
      scrollamaId = props.scrollamaId,
      progressThreshold = props.progressThreshold,
      innerHeight = props.innerHeight;
  var isBrowser = typeof window !== "undefined";
  var scrollTop = isBrowser ? document.documentElement.scrollTop : 0;
  var direction = lastScrollTop < scrollTop ? 'down' : 'up';
  var rootMargin = useRootMargin(offset);
  var ref = useRef(null);

  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      isIntersecting = _useState2[0],
      setIsIntersecting = _useState2[1];

  var _useInView = useInView({
    rootMargin: rootMargin,
    threshold: 0
  }),
      inViewRef = _useInView.ref,
      entry = _useInView.entry;

  var progressRootMargin = useMemo(function () {
    return useProgressRootMargin(direction, offset, ref, innerHeight);
  }, [direction, offset, ref, innerHeight]);

  var _useInView2 = useInView({
    rootMargin: progressRootMargin,
    threshold: progressThreshold
  }),
      scrollProgressRef = _useInView2.ref,
      scrollProgressEntry = _useInView2.entry;

  var setRefs = useCallback(function (node) {
    ref.current = node;
    inViewRef(node);
    scrollProgressRef(node);
  }, [inViewRef, scrollProgressRef]);
  React__default.useEffect(function () {
    if (isIntersecting) {
      var _scrollProgressEntry$ = scrollProgressEntry.target.getBoundingClientRect(),
          height = _scrollProgressEntry$.height,
          top = _scrollProgressEntry$.top;

      var progress = Math.min(1, Math.max(0, (window.innerHeight * offset - top) / height));
      onStepProgress && onStepProgress({
        progress: progress,
        scrollamaId: scrollamaId,
        data: data,
        element: scrollProgressEntry.target,
        entry: scrollProgressEntry,
        direction: direction
      });
    }
  }, [scrollProgressEntry]);
  React__default.useEffect(function () {
    if (entry && !entry.isIntersecting && isIntersecting) {
      onStepExit({
        element: entry.target,
        scrollamaId: scrollamaId,
        data: data,
        entry: entry,
        direction: direction
      });
      setIsIntersecting(false);
      handleSetLastScrollTop(scrollTop);
    } else if (entry && entry.isIntersecting && !isIntersecting) {
      setIsIntersecting(true);
      onStepEnter({
        element: entry.target,
        scrollamaId: scrollamaId,
        data: data,
        entry: entry,
        direction: direction
      });
      handleSetLastScrollTop(scrollTop);
    }
  }, [entry]);
  return /*#__PURE__*/React__default.cloneElement(React__default.Children.only(children), {
    'data-react-scrollama-id': scrollamaId,
    ref: setRefs,
    entry: entry
  });
};

Step.defaultProps = {
  onStepProgress: null,
  onStepEnter: function onStepEnter() {},
  onStepExit: function onStepExit() {}
};

export { Scrollama, Step };
//# sourceMappingURL=index.es.js.map
